/**** ImageManager.as  	February 2010** @author Charles S.Davis** Manage fly transitions between series of images with next & previous arrows** Licensed under the MIT License* * Copyright (c) 2009 Charles S.Davis* * Permission is hereby granted, free of charge, to any person obtaining a copy of* this software and associated documentation files (the "Software"), to deal in* the Software without restriction, including without limitation the rights to* use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of* the Software, and to permit persons to whom the Software is furnished to do so,* subject to the following conditions:* * The above copyright notice and this permission notice shall be included in all* copies or substantial portions of the Software.* * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS* FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR* COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER* IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN* CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.* * http://www.opensource.org/licenses/mit-license.php*    */package com.dtk{	import flash.display.Sprite;	import flash.display.Loader;	import flash.net.URLRequest;	import flash.net.URLLoader;	import flash.events.Event;	import flash.events.MouseEvent;	import com.dtk.RadialLoading;	import com.dtk.IconLoader;	import caurina.transitions.*;		public class ImageManager extends Sprite	{		public var imageWidth:uint;		public var imageHeight:uint;		public var spacing:uint;		public var imageArray:Array;				private var xStart:uint;		private var yStart:uint;		private var xPos:uint;		private var yPos:uint;		private var currentImage:uint;		private var travel:uint;		private var totalWidth:uint;		private var totalheight:uint;		private var lgRadius:uint;		private var smRadius:uint;		private var over:Boolean;		private var movement:String;				/**		 *	PARAMS: 	@param		imageWidth		uint		width of images		 *				@param  	imageHeight		uint		height of images		 *				@param		spacing			uint		spacing between each image		 * 	 			@param		imageArray		Array    	associative array of images with url & title (see NOTE below)		 *		 *	USAGE:		import com.dtk.ImageManager		 *		 *				var im:ImageManager = new ImageManager( imageWidth, imageHeight, spacing, imageArray );		 *				im.x = mm;		 *				im.y = nn;		 *				addChild( im );		 *		 *	ARRAY:		var imageArray = [ ];		 *				imageArray.push( { url: 'images/img_1.jpg', title: 'My first image' } ); // title optional		 *				..		 */		public function ImageManager( imageWidth:uint, imageHeight:uint, spacing:uint, imageArray:Array ):void		{			this.imageWidth  = imageWidth;			this.imageHeight = imageHeight;			this.spacing     = spacing;			this.imageArray  = imageArray;						currentImage = 0;  // start at first image						loadImages( );		}				/**		 *	initial steps:	calc dimensions & draw container for all images		 *					load radial loading indicator		 *					add images to container		 *					init event listener for first image loaded			 *					draw & set mask		 */		private function loadImages( ):void		{			// calc total bg width & height including spacing			var totalWidth:uint = ( imageArray.length * imageWidth ) + (( imageArray.length + 1) * spacing );			var totalHeight:uint = imageHeight + 2 * spacing;						// init starting position			xStart = yStart = 0;			// draw bg sprite			var bg:Sprite = new Sprite( );			bg.graphics.beginFill( 0xFFFFFF );			bg.graphics.drawRect( xStart, yStart, totalWidth, totalHeight );			bg.graphics.endFill( );			bg.name = 'bg';			addChild( bg );						// set petal size for loading indicator			lgRadius = 14;			smRadius =  8;			// loading indicator			var r:RadialLoading = new RadialLoading( lgRadius, smRadius, 3, 0x999999 );			r.x = xStart + spacing + imageWidth / 2;			r.y = yStart + imageHeight / 2 - smRadius;			r.name = 'loading';			addChild( r );						// define location of 1st image			xPos = xStart + spacing;			yPos = yStart + spacing;						// add images onto container sprite bg			for ( var i:uint=0; i<imageArray.length; i++ )			{				// image loader				var l:Loader = new Loader;				l.load(new URLRequest( imageArray[i].url ));					// if first image add event listener for removing radial loading indicator				if ( i == 0 )				{					// event listener fires after 1st image is loaded					l.contentLoaderInfo.addEventListener( Event.COMPLETE, firstImageLoaded );				}					l.x = xPos;				l.y = yPos;				l.name = 'image_' + i;				bg.addChild( l );					xPos += imageWidth + spacing;			}						// draw mask			var m:Sprite = new Sprite( );			m.graphics.beginFill( 0xFF0000 );			m.graphics.drawRect( xStart, yStart, imageWidth + 2 * spacing, imageHeight + 2 * spacing );			m.graphics.endFill( );			m.name = 'masker';			addChild( m );				// set mask			getChildByName( 'bg' ).mask = getChildByName( 'masker' );		}				/**		 *	after 1st image is loaded:  remove laoding indicator		 *								load next & previous buttons & hide		 *								draw mouse window & add event listeners		 */		private function firstImageLoaded( e:Event ):void		{			// remove loading indicator			for ( var j:uint=0; j<numChildren; j++ )			{				if ( getChildAt( j ).name == 'loading' )				{					removeChildAt( j );				}			}				// load previous button & hide			var prev:IconLoader = new IconLoader( 'nav-arrows/prev.png', 21, 30 );			prev.x = xStart + 2 * spacing;			prev.y = yStart + imageHeight / 2 - 15;			prev.name = 'prev';			prev.alpha = 0;			addChild( prev );				// load next button & hide			var next:IconLoader = new IconLoader( 'nav-arrows/next.png', 21, 30 );			next.x = xStart + imageWidth - 20;			next.y = yStart + imageHeight / 2 - 15;			next.name = 'next';			next.alpha = 0;			addChild( next );				// interactive sprite intercepts mouse events			var ms:Sprite = new Sprite( );			ms.graphics.beginFill( 0xFFFFFF, 0 );			ms.graphics.drawRect( xStart+spacing, yStart+spacing, imageWidth, imageHeight );			ms.graphics.endFill( );			ms.addEventListener( MouseEvent.MOUSE_OVER, onMouseOver );			ms.addEventListener( MouseEvent.MOUSE_OUT, onMouseOut );			ms.addEventListener( MouseEvent.CLICK, onMouseClick );			ms.buttonMode = true;			addChild( ms );		}				/**		 * 	on MOUSE_OVER:	set var.over to true		 *					manage next & prev alpha based on var.currentImage		 */		private function onMouseOver( e:MouseEvent ):void		{			over = true;			this.addEventListener( MouseEvent.MOUSE_MOVE, onMouseMoving );						if ( currentImage > 0 )			{				Tweener.addTween ( getChildByName( 'prev' ), { alpha: 1, time: 1 } );			}						if ( currentImage < imageArray.length )			{				Tweener.addTween ( getChildByName( 'next' ), { alpha: 1, time: 1 } );			}		}				/**		 * 	on MOUSE_OUT:	set var.over to false		 *					set next & prev alpha to 0		 *					remove MOUSE_MOVE event listener		 */		function onMouseOut( e:MouseEvent ):void		{			over = false;			Tweener.addTween ( getChildByName( 'next' ), { alpha: 0, time: 1 } );			Tweener.addTween ( getChildByName( 'prev' ), { alpha: 0, time: 1 } );			this.removeEventListener(MouseEvent.MOUSE_MOVE, onMouseMoving );		}				/**		 * 	on MOUSE_MOVE:	determine if movement LEFT or RIGHT		 *					manage next & prev alpha based on var.currentImage		 */		private function onMouseMoving( e:MouseEvent ):void		{			// LEFT if mouse is over left half of screen and image id is not 0			if ( mouseX > (xStart+spacing) && mouseX < (xStart+spacing+imageWidth/2) ) 			{				if ( currentImage != 0 )				{					movement = 'LEFT';				}			}						// RIGHT if mouse is over right half of screen and image id is last			if ( mouseX > (xStart+spacing+imageWidth/2) )			{				if ( currentImage < imageArray.length )				{					movement = 'RIGHT';				}			}						// if not 1st image show previous arrow			if ( currentImage != 0 )			{								Tweener.addTween ( getChildByName( 'prev' ), { alpha: 1, time: 1 } );			}						// if not last image show nexyt arrow			if ( currentImage < imageArray.length )			{				Tweener.addTween ( getChildByName( 'next' ), { alpha: 1, time: 1 } );			}						// if first hide previous arrow 			if ( currentImage == 0 )			{				Tweener.addTween ( getChildByName( 'prev' ), { alpha: 0, time: 1 } );			}						// if last hide next arrow			if ( currentImage == imageArray.length - 1 )			{				Tweener.addTween ( getChildByName( 'next' ), { alpha: 0, time: 1 } );			}		}				/**		 * 	on CLICK: 	based on var.movement increment/decrement var.currentImage		 *				manage next & prev based on var.currentImage		 *				calc end position of container for tween		 *				tween if in not past first or last image		 */		private function onMouseClick( e:MouseEvent ):void		{			// increment image id if var.movement is RIGHT			if ( movement == 'RIGHT' )			{				currentImage++;			}						// decrement image id if var.movement is LEFT			if ( movement == 'LEFT' )			{				if ( currentImage > 0 )					currentImage--;			}						// control alpha of arrows after changing image id value						if ( currentImage != 0 )			{				Tweener.addTween ( getChildByName( 'prev' ), { alpha: 1, time: 1 } );			}			else			{				Tweener.addTween ( getChildByName( 'prev' ), { alpha: 0, time: 1 } );			}						if ( currentImage < imageArray.length - 1 )			{				Tweener.addTween ( getChildByName( 'next' ), { alpha: 1, time: 1 } );			}			else			{				Tweener.addTween ( getChildByName( 'next' ), { alpha: 0, time: 1 } );			}						// calc new position of sprite bg based on var currentImage			travel = currentImage * (imageWidth + spacing);						// don't allow tween past first or last images			if ( currentImage >= 0 && currentImage < imageArray.length )			{				Tweener.addTween ( getChildByName( 'bg' ), { x: -travel, time: 1 } );			}		}	}}